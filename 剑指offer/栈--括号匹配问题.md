## 基本的括号匹配问题（利用栈的思想）

```c++
#include <iostream>
#include <stack>
#include <string>

using namespace std;
int match(char *str)
{
	stack<char> S;
	int len = strlen(str);
	char t;
	for(int i = 0;i<len;i++)
	{
		if(str[i] == '(' || str[i] == '[' || str[i] == '{')
		{
            S.push(str[i]);
		}
		else if(str[i] == ')' || str[i] == ']' || str[i] == '}')
        {
            if(S.empty())
                return 3;// 代表右边的括号是多余的
			if(str[i] == ')')
			{
				t = S.top();
				if(t == '(')
					S.pop();
				else
					return 1;// 不匹配
			}
			if(str[i] == '}')
			{
				t = S.top();
				if(t == '{')
					S.pop();
				else
					return 1;
			}
			if(str[i] == ']')
			{
				t = S.top();
				if(t == '[')
					S.pop();
				else
					return 1;
			}
        }
	}
	if(!S.empty())
		return 2;// 结束的时候栈不是空的 左括号有多余
	if(S.empty())
		return 0;
}

int main()
{
	/*
		0 表示匹配成功
		1 表示匹配不成功
		2 表示匹配左括号多余
		3 表示匹配右括号多余
	*/
	char str[100] = "(())abc{[(])}";
	/*
		测试用例：
		char a[] = "(())abc{[(])}";//左右括号次序匹配不正确
		char b[] = "(()))abc{[]}";//右括号多于左括号
		char c[] = "(()()abc{[]}";//左括号多于右括号
		char d[] = "(())abc{[]()}";//左右括号匹配正确
	*/
	cout << match(str) << endl;
	return 0;
}
```

## 括号匹配升级版本：

一般的括号匹配问题是这样的：

+ 给出一个字符串，判断这个括号匹配是不是合法的括号匹配。
+ 如`"(("` 和 `"())"`都不是合法的括号匹配，但是`"()()()"，"(()())()"`等就是合法的括号匹配。  

这个问题解决起来非常简单，相信大家都知道怎么解决。

现在给出一个加强版的括号匹配问题： 给出`n`个由括号 `'('` 和 `‘)’` 组成的字符串，请计算出这些字符串中有多少对字符串满足`si + sj`是合法的括号匹配。如果`si + sj`和`sj + si`都是合法的括号匹配`(i ≠ j)`，那么这两种搭配都需要计入答案；如果对于`si`，`si + si`是合法的括号匹配，那么也需要计入答案。

##### **输入描述:**

```
第一行是一个整数n，表示字符串的个数；接下来n行是n个非空字符串，全部由'('和')'组成。1 <= n <= 3 * 105，字符串的长度之和不超过3 * 105。
```

##### **输出描述:**

```
一个整数，表示满足条件的字符串对的数量。
```

 **示例：**

```md
输入：
3
()
(
)
输出：
2

输入：
5
(()
)))))
()()()
(((
))
输出：
1
```